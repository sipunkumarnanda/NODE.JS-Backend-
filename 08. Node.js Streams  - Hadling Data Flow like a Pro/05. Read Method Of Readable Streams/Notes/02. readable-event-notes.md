# ğŸ“Œ **Understanding `readable` Event in Readable Streams**  

In Node.js, the `readable` event is emitted when a **Readable Stream** has data available to be read. It provides **manual control** over how data is read from the stream.  

---

## **1ï¸âƒ£ What is the `readable` Event?**  
ğŸ”¹ The `readable` event is triggered when a chunk of data is **added to the internal buffer** and is ready to be read.  
ğŸ”¹ Instead of using the `"data"` event (which pushes data automatically), the `readable` event allows **pull-based reading** using `readStream.read()`.  

---

## **2ï¸âƒ£ Key Characteristics of `readable` Event**
âœ” **Pull-based approach** â†’ You manually decide when to read data using `readStream.read()`.  
âœ” **More control over memory usage** â†’ Unlike the `"data"` event, it does not automatically consume data.  
âœ” **Efficient for custom processing** â†’ Useful when you need fine-grained control over how much data is read at a time.  

---

## **3ï¸âƒ£ Example: Using `"readable"` Event to Read Data**
```javascript
import fs from 'fs';

const readStream = fs.createReadStream("example.txt", { highWaterMark: 4 });

readStream.on("readable", () => {
    console.log("Readable event triggered!");

    let chunk;
    while ((chunk = readStream.read()) !== null) { 
        console.log(`Received chunk: ${chunk.toString()}`);
    }
});
```
### **ğŸ” Explanation:**
1ï¸âƒ£ **`highWaterMark: 4`** â†’ Reads data in chunks of **4 bytes**.  
2ï¸âƒ£ **`"readable"` event fires** when new data is available in the internal buffer.  
3ï¸âƒ£ **`readStream.read()`** is used inside a `while` loop to **manually pull data** from the buffer.  
4ï¸âƒ£ The loop runs until `readStream.read()` returns `null`, meaning no more data is available **(buffer is empty for now).**  

---

## **4ï¸âƒ£ Difference Between `"readable"` and `"data"` Event**
| Feature            | `"readable"` Event | `"data"` Event |
|--------------------|------------------|---------------|
| **Data flow** | **Pull-based** (Manual) | **Push-based** (Automatic) |
| **Control over reading** | âœ… Yes (You decide when to read) | âŒ No (Data is pushed automatically) |
| **Memory Efficiency** | âœ… Can optimize based on `highWaterMark` | âŒ May consume more memory |
| **Use Case** | Fine-grained control over reading | Quick and automatic data processing |

---

## **5ï¸âƒ£ When to Use the `"readable"` Event?**
âœ… When you **need control** over how much data is read at a time.  
âœ… When you **don't want automatic data flow** (like in the `"data"` event).  
âœ… When dealing with **custom parsers** or **structured data processing** (e.g., processing JSON, CSV line by line).  
âœ… When reading data **in specific chunk sizes** for **memory efficiency**.  

---

## **6ï¸âƒ£ Another Example: Reading a File Byte by Byte**
```javascript
import fs from 'fs';

const readStream = fs.createReadStream("example.txt", { highWaterMark: 1 }); // Read one byte at a time

readStream.on("readable", () => {
    let byte;
    while ((byte = readStream.read(1)) !== null) { 
        console.log(`Byte read: ${byte.toString()}`);
    }
});
```
### **Output (for file containing "Hello"):**
```
Byte read: H
Byte read: e
Byte read: l
Byte read: l
Byte read: o
```
Here, we **manually pull one byte at a time** using `readStream.read(1)`.

---

## **7ï¸âƒ£ `readable` Event Lifecycle**
1ï¸âƒ£ **Initial State:** Stream is created, but no data is available yet.  
2ï¸âƒ£ **`readable` Event Fires:** Data is added to the internal buffer and is ready to be read.  
3ï¸âƒ£ **Reading Process:** `readStream.read(size)` is called to manually pull data.  
4ï¸âƒ£ **Buffer Drains:** Once all data is read, `readStream.read()` returns `null`.  
5ï¸âƒ£ **`readable` Fires Again:** When new data arrives, the cycle repeats until the stream ends.  

---

## **8ï¸âƒ£ Summary**
ğŸ”¹ **`"readable"` is a manual pull-based event** that gives you fine control over data reading.  
ğŸ”¹ **Use `readStream.read(size)`** to control how much data is read.  
ğŸ”¹ **More efficient for structured data processing** compared to `"data"` event.  
ğŸ”¹ **Best for controlled memory usage**, especially when working with large files.  

---