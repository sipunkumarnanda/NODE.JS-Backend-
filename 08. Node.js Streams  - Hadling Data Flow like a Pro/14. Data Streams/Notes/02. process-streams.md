### **Three Types of Data Streams Connected to a Process**  

Whenever a process starts in an operating system, three fundamental data streams are automatically associated with it:  

1. **Standard Input (stdin) â€“ Readable Stream**  
2. **Standard Output (stdout) â€“ Writable Stream**  
3. **Standard Error (stderr) â€“ Writable Stream**  

These streams allow the process to interact with external sources like the terminal, files, or other processes.  

---

## **1. Standard Input (stdin) â€“ Readable Stream**  
- **Purpose:** Used to receive input from the user or another process.  
- **Type:** Readable stream (data flows **into** the process).  
- **Example Sources:** Keyboard input, data piped from another process.  
- **Access in Node.js:** `process.stdin`  

### **Example: Reading User Input in Node.js**
```javascript
process.stdin.on('data', (chunk) => {
    console.log(`User Input: ${chunk.toString().trim()}`);
});
```
- The process waits for user input and logs it when received.  

---

## **2. Standard Output (stdout) â€“ Writable Stream**  
- **Purpose:** Used to display output generated by the process.  
- **Type:** Writable stream (data flows **out** from the process).  
- **Example Destinations:** Terminal, file redirection, piped to another process.  
- **Access in Node.js:** `process.stdout`  

### **Example: Writing Output in Node.js**
```javascript
process.stdout.write("Hello, this is standard output!\n");
```
- Unlike `console.log()`, `process.stdout.write()` does **not** automatically add a newline (`\n`).  

---

## **3. Standard Error (stderr) â€“ Writable Stream**  
- **Purpose:** Used for logging errors and warnings separately from regular output.  
- **Type:** Writable stream (data flows **out** from the process, like stdout).  
- **Example Destinations:** Terminal, log files, error tracking systems.  
- **Access in Node.js:** `process.stderr`  

### **Example: Logging Errors in Node.js**
```javascript
process.stderr.write("This is an error message!\n");
```
- Error messages are sent to stderr so they can be handled separately from normal output.  

---

## **How These Streams Work Together?**  
When you run a process in a terminal or command line, these streams work as follows:  

```sh
node script.js < input.txt > output.txt 2> error.log
```
- `< input.txt` â†’ Redirects **stdin** to read from `input.txt`.  
- `> output.txt` â†’ Redirects **stdout** to `output.txt`.  
- `2> error.log` â†’ Redirects **stderr** to `error.log`.  

---

## **Practical Example: Using All Three Streams**  
```javascript
import fs from 'fs';

// Read from stdin (User Input)
process.stdin.on('data', (chunk) => {
    try {
        // Simulating processing data
        const message = `Processed: ${chunk.toString().trim()}\n`;
        
        // Write output to stdout
        process.stdout.write(message);
        
        // Save output to a file
        fs.appendFileSync('output.txt', message);
    } catch (error) {
        // Log error to stderr
        process.stderr.write(`Error: ${error.message}\n`);
    }
});
```

### **How It Works?**  
1. The user enters input (`stdin`).  
2. The program processes the input and outputs it (`stdout`).  
3. If an error occurs, it's logged separately (`stderr`).  

---

## **Summary Table**  

| Stream  | Type | Purpose | Example Use Case | Node.js Access |
|---------|------|---------|------------------|---------------|
| `stdin` | Readable | Receives user/process input | Accepting user input | `process.stdin` |
| `stdout` | Writable | Outputs data | Displaying results | `process.stdout` |
| `stderr` | Writable | Logs errors | Logging errors separately | `process.stderr` |

By understanding these streams, you can efficiently manage input, output, and error handling in your Node.js applications. ðŸš€  