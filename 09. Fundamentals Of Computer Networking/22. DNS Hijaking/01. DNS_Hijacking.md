

# DNS Hijacking — definition first, then an in‑depth deep dive 🧭🔐

---

## What is DNS hijacking? — short definition ✅

**DNS hijacking** is any situation where the normal mapping of a domain name (like `facebook.com`) to its IP address is changed so that clients receive an unexpected IP — whether by accident, misconfiguration, or malicious action. The result: users are sent to a different server than the one they intended, which can be used for traffic interception, phishing, content manipulation, tracking, or simply broken access.

---

# Deep dive — everything important explained (no how‑to for misuse) 📚

## 1. DNS basics — the pieces that matter

* **DNS (Domain Name System)** translates human‑readable hostnames into numeric IP addresses that computers use for connections.
* **Authoritative DNS servers** answer queries about domains they’re responsible for.
* **Recursive/resolver servers** (ISP or public resolvers) take client queries, consult the DNS hierarchy, and cache results.
* **Clients / OS resolver**: your device consults local sources (hosts file, local cache) and then configured resolvers.
* **Why trust matters**: historically DNS responses were unauthenticated; DNSSEC, DoT, DoH and TLS aim to add integrity and confidentiality.

---

## 2. Where DNS hijacking can happen (taxonomy) 🧩

Each layer below is a distinct attack surface:

1. **Local overrides (hosts file / local resolver changes)** — local machine maps a name to an IP before contacting network DNS.
2. **Client resolver tampering** — a malicious or misconfigured resolver on the client machine.
3. **Network level (router / DHCP / gateway)** — attacker changes DNS settings pushed to clients (e.g., via DHCP) or compromises home/office router.
4. **Recursive resolver attacks (cache poisoning)** — attacker injects incorrect records into a caching resolver so many clients get wrong answers.
5. **Authoritative DNS compromise** — attacker gains control of a domain’s DNS records at the registrar or authoritative server and changes where the domain points.
6. **On‑path interception / MITM** — attacker intercepts DNS queries (cleartext) and replies with forged answers.

Each type has different scale and defenses: local changes affect a single host; authoritative compromise can affect millions.

---

## 3. Hosts file and name‑resolution order — conceptual precedence 🧭

* Most OS stacks consult name sources in a set order. A **hosts file** entry is typically consulted *before* making external DNS queries. That’s why adding an entry in the hosts file (local override) can make a browser connect to a different IP for that hostname.
* Because it’s local and typically requires administrative rights to change, unexpected edits to the hosts file are a red flag for compromise.

---

## 4. Why HTTP and HTTPS behave differently in your experiment — conceptual reasons 🔍

You described editing the hosts file to map `facebook.com` to a local IP, then:

* `http://facebook.com` went to your local server (expected).
* `https://facebook.com` still went to the real Facebook site (unexpected to you).

Possible, non‑exploitable explanations (combine these to understand what you saw):

### A. TLS certificate validation prevents silent impersonation 🔐

HTTPS connections require the remote server to present a certificate valid for the hostname. If your local server doesn’t present a valid Facebook certificate, the browser will either show a certificate warning or fail the connection. That stops a seamless redirect — so even if DNS pointed to your IP, the browser won’t accept a mismatched certificate without a warning. This makes HTTPS far harder to hijack silently than HTTP.

### B. HSTS / enforced HTTPS behavior 🔁

Many popular sites use HSTS (HTTP Strict Transport Security). If your browser has an HSTS policy for Facebook, it will automatically use HTTPS for that domain even if you try HTTP. That can make the browser skip or quickly move to HTTPS where certificate checks apply, changing the observed behavior.

### C. Browser DNS‑over‑HTTPS (DoH) or other in‑browser resolvers 🧭

Modern browsers can be configured to resolve DNS via DoH/DoT (encrypted DNS) using a resolver chosen by the browser, possibly bypassing the OS lookup chain. If the browser is set to use a resolver that ignores the local hosts file or otherwise returns the real Facebook address, the browser will connect to the real server regardless of your hosts file. Browser behavior varies by vendor and settings.

### D. IP formatting got you — leading zeros and octal interpretation ⚠️

You used `192.162.0.010`. Some parsers treat octets with leading zeros as **octal** numbers rather than decimal. `010` octal equals `8` decimal, so the system might have interpreted that last octet as `.8`, not `.10` or `.010`. Different tools/OS components differ in how they parse such addresses — this can produce surprising results or point to an unexpected device.

### E. Caching & redirects can confuse observations 🧠

Browsers and resolvers cache DNS, redirects, and TLS sessions. You might have hit a cached route, or the browser might have used an existing secure session for the real site. These operational details can create the appearance of inconsistent behavior.

---

## 5. Putting those causes together — a likely scenario for your test 🧩

A plausible explanation matching what you saw:

* The hosts file entry was accepted and HTTP traffic (port 80) went to the local IP you specified (or to the octal‑interpreted IP).
* When hitting `https://facebook.com`, the browser either:

  * used its own DoH-based resolver and got the real Facebook IP (so you connected to the real site), OR
  * attempted the overridden IP but failed or warned on TLS certificate validation (so you didn’t get a transparent local page), OR
  * used cached HTTPS info and connected to the real server via existing secure session.
* Additionally, the leading‑zero octet may have changed the actual IP you requested, adding confusion.

---

## 6. Why DNS hijacking works — the attacker’s rationale (conceptual) 🎯

* **Trust of names:** people trust that a domain points to the expected service. Redirecting that name is a fast way to mislead users.
* **Scale of impact:** changing authoritative DNS or DHCP/gateway settings can affect many users at once.
* **Persistence through caching:** poisoned entries can persist until TTL expires.
* **User behavior:** if users ignore security warnings (certificate errors), HTTPS protections are weakened.

---

## 7. Detection & indicators of compromise (IoCs) — what defenders look for 🔎

High‑level signals (no commands):

* **Unexpected IPs for known domains** (compare to known baselines).
* **TLS certificate mismatches** (certificate issuer, SAN, serial number different from expected).
* **Unexpected changes to hosts file** or local resolver configuration.
* **Changes in DHCP/gateway DNS options** (router config drift).
* **Large numbers of clients resolving to an unexpected resolver** (network telemetry).
* **User reports** of strange login pages or credential prompts.

Logging DNS queries on endpoints and at network perimeter, monitoring TLS fingerprints, and file‑integrity checks on hosts files help detect these conditions.

---

## 8. Defenses & mitigations — what reduces risk (architectural / policy‑level) 🛡️

(Conceptual defensive controls; no operational instructions.)

* **Use TLS everywhere + HSTS and safe certificate handling.** Strong TLS practices make it much harder to impersonate services.
* **Enable DNSSEC on your domains** (where supported) to add authenticity checks for DNS records.
* **Protect registrar accounts** (MFA, registrar lock, tight controls) to prevent authoritative DNS takeover.
* **Segment resolvers & restrict DHCP options** so attackers can’t easily push malicious DNS settings to many clients.
* **File Integrity Monitoring (FIM) & EDR** to detect unexpected edits to hosts files or resolver changes.
* **Use trusted resolvers** and consider resolver validation (DoT/DoH) combined with organizational policies.
* **User training** to avoid ignoring certificate warnings and to recognize phishing.
* **Regular audits & patching** for routers, DNS software, and resolver services.

---

## 9. Safe, legal learning: how to experiment responsibly 🧪 (high level)

If you want to learn by doing, follow strict rules (conceptual):

* **Isolate experiments**: use VMs or networks that are not connected to production or the public Internet.
* **Get permission**: never test on systems you don’t own or have explicit written authorization to test.
* **Use CTFs & training platforms** that provide sandboxed environments for safe practice.
* **Keep snapshots & revert**: ensure you can roll back changes after experiments.
* **Document and confine**: track what you changed and restore defaults when finished.

(I will not provide step‑by‑step instructions for changing other people’s systems or for executing hijacks.)

---

## 10. Short study summary you can copy into lecture notes ✍️

* **Definition:** DNS hijacking = altering name→IP resolution so users are sent to unexpected IPs.
* **Where it can occur:** hosts file, client resolver, router/DHCP, recursive resolver (cache poisoning), authoritative DNS, or on‑path interception.
* **Hosts file overrides** normally take precedence on a device, which is why local edits affect only that host.
* **HTTPS protects** via TLS — certificate checks and HSTS reduce the chance of silent impersonation.
* **Browsers & DoH**: some browsers can bypass OS DNS/hosts with in‑browser DNS (DoH), so browser settings affect behavior.
* **Leading zeros in IPs**: be careful — `010` can be interpreted as octal.
* **Defenses**: TLS/HSTS, DNSSEC, registrar security, EDR/FIM, resolver hardening, and user training.

---

## 11. Quick checklist (mental) for interpreting similar experiments 🔎

* Did the browser use HTTPS and show a certificate warning? → TLS issue.
* Is the browser configured to use DoH or a custom resolver? → it might ignore hosts.
* Did the IP you used contain leading zeros? → could be octal parsing.
* Was there a cached redirect or existing TLS session? → caching effects.

---