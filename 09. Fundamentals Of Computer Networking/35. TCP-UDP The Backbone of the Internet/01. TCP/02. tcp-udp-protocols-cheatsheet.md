

# 🌐 All those protocols (HTTP, FTP, SMTP, WebRTC, …) — how they run on TCP / UDP (in depth) 🧩

Nice — let’s unpack how the Internet’s application protocols map onto the transport layer (TCP vs UDP), **why** they pick one or the other, and what special bits (ports, exceptions, modern twists) you should know. I’ll explain each protocol, its typical transport, why that transport makes sense, and any important implementation details (QUIC, DTLS, SCTP, etc.).
---

## 🔁 Quick transport primer: TCP vs UDP (refresh)

* **TCP (Transmission Control Protocol)** — connection-oriented, reliable, ordered, congestion-controlled. Great when correctness matters (web pages, files, email). 🔗✅
* **UDP (User Datagram Protocol)** — connectionless, low overhead, no guaranteed delivery/order, supports multicast. Great for low-latency, real-time use (voice, video, games). 🏎️⚡
* **Important nuance:** Applications can layer their own reliability on UDP (e.g., QUIC, application ACKs + retransmits), so “UDP = unreliable” is a simplification — it’s the transport primitive.

---

## 📚 How applications choose: the design tradeoffs

* **Reliability vs latency:** If you can’t tolerate missing bytes (HTTP, FTP), choose TCP. If a late packet is worse than lost packet (live audio/video), choose UDP.
* **Ordering:** TCP gives ordering; if an app needs message boundaries or unordered delivery (e.g., certain realtime flows) it may choose UDP or an alternate like SCTP.
* **Firewall/NAT friendliness:** TCP is more firewall/NAT friendly (stateful). UDP is trickier and often needs NAT traversal (STUN/TURN).
* **Multicast support:** UDP supports IP multicast (useful for some streaming/distribution scenarios).
* **New transports:** QUIC (user-space protocol) runs over UDP but provides TCP-like reliability + better multiplexing and integrated TLS.

---

## ⚙️ Protocol-by-protocol deep dive

### 1) **HTTP / HTTPS** 🌍

* **Transport:** TCP (HTTP/1.0, HTTP/1.1, HTTP/2) — **HTTP/3 uses QUIC over UDP**.
* **Ports:** 80 (HTTP), 443 (HTTPS / HTTP/2 / HTTP/3 via QUIC).
* **Why TCP (traditionally):** page loads need reliable, ordered delivery of bytes and out-of-order recovery; TLS sits on top of TCP for secure connections.
* **HTTP/3 twist:** QUIC moves transport to user space over UDP, providing multiplexed streams, lower head-of-line blocking, and integrated TLS 1.3. So HTTP now behaves like application-level reliability built on UDP. 🔁➡️UDP

---

### 2) **FTP (File Transfer Protocol)** 📂

* **Transport:** TCP.
* **Ports:** 21 (control), 20 (data, in active mode) — passive mode uses ephemeral ports negotiated by the server.
* **Why TCP:** file transfers need reliable, ordered delivery. FTP uses separate control and data channels which complicates NAT; that’s why SFTP (over SSH/TCP) and FTPS exist as easier modern choices.

---

### 3) **SMTP (Email transfer)** ✉️

* **Transport:** TCP.
* **Ports:** 25 (SMTP), 587 (submission), 465 (smtps/legacy TLS).
* **Why TCP:** mail delivery must be reliable and ordered; servers exchange SMTP commands and responses; STARTTLS adds encryption over the same TCP connection.

---

### 4) **IMAP / POP3 (Email retrieval)** 📥

* **Transport:** TCP.
* **Ports:** POP3 110 / 995 (TLS), IMAP 143 / 993 (TLS).
* **Why TCP:** mailbox operations and message transfer demand reliability and consistent session semantics.

---

### 5) **DNS (Domain Name System)** 🧭

* **Transport:** UDP (most queries) — TCP for large responses/zone transfers.
* **Ports:** 53 (UDP and TCP).
* **Why UDP mostly:** short query/response fits UDP’s low overhead and low latency. However large responses, DNSSEC, zone transfers (AXFR) and TCP fallback use TCP. Also modern encrypted options: DNS over HTTPS (DoH — HTTP/2 or HTTP/3 over TCP/QUIC) and DNS over TLS (DoT — TCP+TLS).

---

### 6) **DHCP (IP address assignment)** 🛰️

* **Transport:** UDP (client↔server).
* **Ports:** server 67, client 68.
* **Why UDP:** broadcast/connectionless discovery fits UDP; simple request/response with retransmit at application level.

---

### 7) **SSH (Secure Shell)** 🔒

* **Transport:** TCP.
* **Port:** 22.
* **Why TCP:** interactive shell and file transfers need reliable ordered byte streams with encryption and authentication.

---

### 8) **Telnet** 🕳️ (legacy)

* **Transport:** TCP (port 23).
* **Why TCP:** interactive terminal requires full-duplex reliable byte stream. (Telnet is insecure; SSH replaced it.)

---

### 9) **RTP / RTCP (Real-time Transport Protocol / control)** 🎧🎬

* **Transport:** UDP (normally), sometimes TCP in constrained networks.
* **Ports:** dynamic RTP ports assigned per session; RTCP adjacent port (used for QoS/metrics).
* **Why UDP:** media packets (audio/video) are time-sensitive; late packets are less useful than fresh ones. RTP often runs over SRTP (secure RTP). For reliability, applications use FEC, retransmit strategies, or adaptive codecs.

---

### 10) **SIP (Session Initiation Protocol)** 📞

* **Transport:** UDP (common), TCP (supported), TLS (SIPS).
* **Ports:** 5060 (UDP/TCP), 5061 (TLS).
* **Why choices vary:** SIP sets up/tears down calls (signalling). UDP is lighter for quick signalling; TCP/TLS used for reliability and security, or when messages exceed UDP size.

---

### 11) **WebRTC** 🧩 (real-time audio/video/data in browsers)

* **Transport:** Primarily **UDP** for media (SRTP) and ICE/STUN/TURN for connectivity.
* **Data channels:** use **SCTP** over **DTLS** over **UDP** (i.e., SCTP → DTLS → UDP).
* **Important components:**

  * **ICE** (connectivity checks), **STUN** (discover public IP), **TURN** (relay when direct connection fails).
  * **SRTP/DTLS** for encryption; TURN can relay over TCP as a fallback.
* **Why UDP:** low latency for media; SCTP for ordered/unordered data channels with multi-streaming features. WebRTC is a great example of layered protocols using UDP for realtime performance while adding security & reliability layers as needed. 🌊

---

### 12) **QUIC** (not exactly “HTTP” but important) ⚡

* **Transport:** runs over **UDP** (user-space).
* **Purpose:** QUIC provides multiplexing, retransmission, congestion control, and integrated TLS — it replaces many TCP use cases for HTTP/3.
* **Why it matters:** It shifts transport from kernel TCP stacks to app-level control, enabling faster connection setup and better handling of multiplexed streams.

---

### 13) **TLS / SSL / DTLS (security layers)** 🔐

* **TLS:** commonly used **on top of TCP** (HTTPS, SMTP STARTTLS, IMAP over TLS).
* **DTLS:** Datagram TLS — **TLS semantics for UDP** (used by applications that need encryption but use UDP, e.g., some WebRTC flows).
* **Why:** encryption + authentication for both reliable (TLS) and datagram (DTLS) transports.

---

### 14) **SCTP (Stream Control Transmission Protocol)** 🔗

* **Transport level protocol:** alternative to TCP/UDP (supports multi-streaming, multi-homing).
* **Where seen:** telecoms, some WebRTC data channels (SCTP encapsulated over DTLS/UDP).
* **Why:** offers message boundaries + multiple independent streams without head-of-line blocking.

---

### 15) **SNMP (Simple Network Management Protocol)** 🖧

* **Transport:** UDP (usually), SNMPv3 can use TCP.
* **Ports:** 161 (agent), 162 (trap).
* **Why UDP:** small, frequent monitoring messages; light weight.

---

### 16) **NTP (Network Time Protocol)** ⏲️

* **Transport:** UDP.
* **Port:** 123.
* **Why UDP:** simple queries for timestamps, low overhead; occasional retries done by the client.

---

### 17) **BGP (Border Gateway Protocol)** 🌐

* **Transport:** **TCP** (port 179).
* **Why TCP:** routing exchanges must be reliable and ordered; session state and long-lived connections are essential.

---

### 18) **SMB / CIFS (file sharing, Windows file shares)** 🗄️

* **Transport:** TCP (modern: port 445) — older variants used NetBIOS over TCP/UDP.
* **Why TCP:** file system semantics require reliability and session consistency.

---

### 19) **LDAP (directory access)** 📇

* **Transport:** TCP (389 standard, 636 LDAPS for TLS).
* **Why TCP:** directory searches and binds expect robust session semantics and reliable transfers.

---

### 20) **MQTT (IoT messaging)** 📡

* **Transport:** TCP (1883), MQTT over TLS (8883).
* **Why TCP:** brokered messaging needs reliable delivery (QoS levels built on TCP). There’s MQTT-SN for constrained networks (UDP variant).

---

### 21) **CoAP (Constrained Application Protocol)** 🔋

* **Transport:** UDP (designed for constrained devices), can use DTLS for security.
* **Port:** 5683 (CoAP), 5684 (CoAPs with DTLS).
* **Why UDP:** tiny devices and lossy networks — low overhead and optional retransmit semantics in the application.

---

### 22) **AMQP, XMPP, POP/IMAP alternatives, databases (MySQL, Postgres)** 🗃️

* **Transport:** almost always TCP (ports like MySQL 3306, Postgres 5432) because database interactions require reliable ordered byte streams. Messaging protocols (AMQP, XMPP) typically run over TCP (and TLS) for reliability and security.

---

## 🔬 Deeper look: application reliability on top of UDP

Many modern stacks prefer UDP as a substrate and implement reliability and congestion control **in user space**, so apps get both lower latency and control. Examples:

* **QUIC** (HTTP/3) — multiplexing, retransmit, congestion control, TLS all over UDP.
* **WebRTC** — uses FEC, selective retransmit, adaptive bitrate, and SCTP for data channels; STUN/TURN for NAT traversal.
* **Custom game engines** — often use UDP with selective ACKs, sequence numbers, and interpolation/prediction to mask loss.

So UDP ≠ no reliability; it’s *flexible* — you choose which guarantees you want.

---

## 🧾 Quick cheat-sheet (protocol → transport → typical ports / notes)

* HTTP → TCP (80) / HTTPS → TCP (443) — *HTTP/3 → QUIC over UDP (443)*.
* FTP → TCP (21 control, 20 data / passive ephemeral ports).
* SMTP → TCP (25) / Submission 587 / SMTPS 465.
* IMAP → TCP (143 / 993 TLS).
* POP3 → TCP (110 / 995 TLS).
* DNS → UDP (53) primary; TCP (53) for big responses/AXFR.
* DHCP → UDP (67 server / 68 client).
* SSH → TCP (22).
* Telnet → TCP (23 — insecure).
* RTP/SRTP → UDP (dynamic ports) (+ RTCP).
* SIP → UDP/TCP (5060) / TLS 5061.
* WebRTC → UDP (SRTP) + SCTP over DTLS over UDP for data channels; uses STUN/TURN/ICE.
* QUIC → UDP (443).
* TLS → typically over TCP; DTLS = TLS for UDP.
* SNMP → UDP (161/162).
* NTP → UDP (123).
* BGP → TCP (179).
* SMB → TCP (445).
* LDAP → TCP (389 / 636).
* MQTT → TCP (1883 / 8883 TLS).
* CoAP → UDP (5683 / 5684 with DTLS).

---

## ✅ Summary — why most application protocols “run on TCP/UDP”

* **Only two widely-deployed basic transport primitives:** TCP and UDP (with a few niche alternatives like SCTP or DCCP). Applications pick the one whose properties match the app’s needs (reliability, latency, ordering, multicast).
* **Flexibility:** UDP can be extended (QUIC, DTLS + SCTP, app-level ARQ) so modern protocols sometimes use UDP as a substrate to build exactly the behaviors they need.
* **Ecosystem & tooling:** OS stacks, NATs/firewalls, and many libraries optimize for TCP/UDP, so protocol designers target these for compatibility.

---